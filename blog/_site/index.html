<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      v3x &middot; dev blog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/blog/public/css/poole.css">
  <link rel="stylesheet" href="/blog/public/css/syntax.css">
  <link rel="stylesheet" href="/blog/public/css/hyde.css">

  <!-- Icons -->
  <link rel="shortcut icon" href="/blogpublic/favicon.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="http://v3x.pw/blog">
          v3x
        </a>
      </h1>
      <p class="lead">Authored by <a href="https://github.com/chris-pauley" target="_blank">@chris-pauley</a>.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/blog">Home</a>

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/blog/about">About</a>
          
        
      
        
      
        
          
        
      
        
      
        
      
    </nav>

    <p class="copyright">&copy; 2018. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://v3x.pw/blog/2018/03/09/focus-not-necessarily-secure">
        Firefox Focus for Android is not necessarily secure
      </a>
    </h1>

    <span class="post-date">09 Mar 2018</span>

    <p>Firefox Focus is Mozilla&#39;s attempt at a privacy-first mobile browser. By all accounts, it&#39;s a great attempt at solving the browser privacy issue on mobile devices. Many complain about the lack of features, but for those focused on maintaining privacy, having less features can many times come as a relief.</p>

<p>I noticed the other day that after running the browser, clearing everything, and opening up a new session I still had links marked as visited. As the main claim of the browser is that it automatically erases your browser history, this is a bit concerning. <a href="https://github.com/mozilla-mobile/focus-android/issues/322">I am not the first</a> to find this issue, and there is a fix on the way. The whole situation is still a bit concerning.</p>

<p>Many years ago <a href="https://blog.mozilla.org/security/2010/03/31/plugging-the-css-history-leak/">Mozilla posted</a> about changes they had made to make sure that an attacker would not be able to generate a list of websites a user had visited by checking the style of visited links. The changes were effective and thorough, but even by their own admission, <a href="https://dbaron.org/mozilla/visited-privacy#limits">would not be all-encompassing</a>. Firefox Focus would truly mitigate all attacks of this kind if the claims of removing browser history were as true as one might hope (or more worryingly, one might assume).</p>

<h2>The Bug</h2>

<p>The bug could be classified as a bug not with Focus, but rather with chromium. This is the stance the firefox team seem to be taking, and it is reasonably valid. The <a href="https://chromium.googlesource.com/chromium/src.git/+/d0ef9df6be5983f6df7e4e050bbad4eb5030e7a2/android_webview/browser/aw_browser_context.cc#140">vector of links</a> is added to automatically, and there&#39;s <a href="https://github.com/mozilla-mobile/focus-android/issues/322">no good way</a> to trigger that to empty from within java. This has been marked as a priority 2 issue by the chromium team and will not be fixed anytime soon.</p>

<p><a href="https://github.com/ahunt">Andrzej Hunt</a> had the right notion to see if the browser context could be unloaded, I don&#39;t know that I entirely agree with the notion that this could not happen other ways. They implement their own system web view which I believe could be destroyed and reloaded, forcing that memory to be dumped and thus getting rid of the list of visited links. For an example of this in action we can look to the Google Chrome app. The incognito tabs in the chrome app not only clear this data but do not share it between tabs. The clear history function also removes this list. They already do a good job of removing on-disk caches, all that needs to happen is have that memory dumped.</p>

<h2>The Fix</h2>

<p>The slightly more concerning thing to me is the fix that has been implemented in the beta. The firefox team has <a href="https://github.com/mozilla-mobile/focus-android/commit/252f761edd20b9ff1f1936862cdb4958a6d044cc">implemented a fix</a> which seems very much like a band-aid. It injects javascript which clears styling rules based on the links in this array (they are accessed by the :visited state of links). This is not only a messy solution from an engineering perspective, but also only sweeps the actual problem under the rug.</p>

<p>Fixes like these do not need to be concerning from the standpoint of whether or not the bug is fixed, but rather from an architectural standpoint. In my day-to-day where privacy is not a huge concern, these types of fixes are a big warning sign that the changes introduce technical debt, poor performance, and will likely break. The real issue is not whether or not the bug was addressed, but the architectural problem of how it was addressed.</p>

<p>From a security standpoint, these types of fixes are even more concerning. This gives the appearance of a reduction of attack surface, but in reality only mitigate a single attack vector. This may make the app feel more secure, but it leaves the user un-aware of the technical reality that not all traces of their browsing history have been erased.</p>

<p>I don&#39;t want to come off as paranoid or extremely upset over this issue, but sweeping issues under the rug like this does not bode well for the claim of privacy made by the firefox team. True privacy and security are upheld by strict standards; the claim of &#39;erasing your browsing history&#39; should not only be effectively true, but technically true. While this one bug may seem small and the fix good enough, I believe that we should hold ourselves (especially in the open source community) to a higher standard when it comes to privacy.</p>

<h2>The Good News</h2>

<p>This bug may not be relevant all that much longer. The firefox team is working on dropping the WebKit renderer for their own Gecko. This would be a huge win for the project, albeit a lot of work. In that scenario any bugs like this could easily be mitigated because both projects are open source. In the current build of the gecko client the bug I have mentioned is already fixed. I am very excited for the gecko viewer to become the renderer for the Focus project.</p>

<h2>In Conclusion</h2>

<p>I hope the members of the firefox team and contributors to the project don&#39;t take this harshly as I very much believe they are doing great work and in perusing the source code of the project while writing this I was thoroughly impressed. Everyone involved is doing great work, and I hope the standards shown throughout the rest of the codebase are kept for a long time to come.</p>

<p>For everyone else, do remember that security is difficult and must be watched with a close eye. Even decade-old exploits can rear their heads if we are not very intentional with every line of code we write.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://v3x.pw/blog/2017/09/29/puppeteer-connect-proxy-cookies">
        Missing Puppeteer Examples
      </a>
    </h1>

    <span class="post-date">29 Sep 2017</span>

    <p>Google finally released <a href="https://developers.google.com/web/updates/2017/04/headless-chrome">Chrome Headless</a> and shortly after, a nodejs library called <a href="https://github.com/GoogleChrome/puppeteer/">Puppeteer</a>. They have a decent document laying out how to use the API but a number of pieces are non-obvious. I needed to do a few things like connect to an existing chrome instance, use an http proxy, </p>

<h3>Connecting to an existing process</h3>

<p>The first thing that can be difficult is attaching to existing chrome processes. I use this quite a bit as I don&#39;t like having multiple servers running chrome or god forbid multiple chrome instances up on a single server. After you&#39;ve got chrome headless running (which can be a pain due to the dependencies) you&#39;ll need to run an http request to <code>localhost:9222/json/version</code> in order to get the <code>webSocketDebuggerUrl</code> which you&#39;re going to pass to <code>browserWSEndpoint</code> when running <a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerconnectoptions">Puppeteer&#39;s <code>connect</code></a> function.</p>

<p>Here&#39;s a code sample from most of my current projects:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">http</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="s1">'http://localhost:9222/json/version'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'data'</span><span class="p">,</span> <span class="nx">str</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">data</span> <span class="o">+=</span> <span class="nx">str</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'end'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> 
        <span class="kd">let</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
        <span class="nx">endpoint</span> <span class="o">=</span> <span class="nx">config</span><span class="p">[</span><span class="s2">"webSocketDebuggerUrl"</span><span class="p">];</span>
    <span class="p">});</span>
<span class="p">});</span>
<span class="c1">// ... </span>
<span class="k">this</span><span class="p">.</span><span class="nx">browser</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">puppeteer</span><span class="p">.</span><span class="nx">connect</span><span class="p">({</span>
    <span class="c1">// ...</span>
    <span class="na">browserWSEndpoint</span><span class="p">:</span> <span class="nx">endpoint</span>
<span class="p">});</span>
</code></pre></div>
<p>There are a couple of annoying issues with this such as not getting all the options as when you launch chrome from node (most notably <code>slowMo</code>). This is far preferable, though, because of the way puppeteer&#39;s launch function works, which is really <em>really</em> gross. <a href="https://github.com/GoogleChrome/puppeteer/blob/a6cf8237b861473cc03a4825d6bc8cc786c1cb4c/lib/Launcher.js#L208">Read the function in question here</a></p>

<p><em>Remember to close your <code>Page</code> when you&#39;re done if you&#39;re connecting to an existing instance!</em></p>

<h3>Connecting to an authenticated HTTP proxy</h3>

<p>The solution to this is simple and won&#39;t be a problem for many, but it was very annoying to figure out. The <code>authenticate</code> function is built already, but has not been released (despite not being noted in the API). If you want to use it, you&#39;ll have to install puppeteer without NPM.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// Chrome headless launched with option `--proxy-server=${the_ip}:${the_port}`</span>
<span class="kd">const</span> <span class="nx">browser</span> <span class="o">=</span> <span class="nx">puppeteer</span><span class="p">.</span><span class="nx">launch</span><span class="p">({</span>
        <span class="c1">// ...</span>
        <span class="na">args</span><span class="p">:</span> <span class="p">[</span> <span class="s2">`--proxy-server=</span><span class="p">${</span><span class="nx">the_ip</span><span class="p">}</span><span class="s2">:</span><span class="p">${</span><span class="nx">the_port</span><span class="p">}</span><span class="s2">`</span> <span class="p">]</span>
    <span class="p">});</span>
<span class="c1">// ...</span>
<span class="kd">const</span> <span class="nx">page</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">browser</span><span class="p">.</span><span class="nx">newPage</span><span class="p">();</span>
<span class="kr">await</span> <span class="nx">page</span><span class="p">.</span><span class="nx">authenticate</span><span class="p">({</span> 
        <span class="na">username</span><span class="p">:</span><span class="s1">'the_proxy_user'</span><span class="p">,</span> 
        <span class="na">password</span><span class="p">:</span><span class="s1">'the_proxy_pass'</span> 
    <span class="p">});</span>
<span class="kr">await</span> <span class="nx">page</span><span class="p">.</span><span class="kr">goto</span><span class="p">(</span><span class="s1">'https://www.google.com/'</span><span class="p">);</span>
</code></pre></div>
<h3>Cookies</h3>

<p>Cookies may be going the way of the dinosaur, but they&#39;re still important in many crawling projects. Here&#39;s a couple of quick lines I use to keep mine in check:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// Store all the cookies for this page </span>
<span class="c1">// you can store these in a file</span>
<span class="kd">var</span> <span class="nx">cookies</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">page</span><span class="p">.</span><span class="nx">cookies</span><span class="p">(</span> <span class="nx">page</span><span class="p">.</span><span class="nx">url</span><span class="p">()</span> <span class="p">);</span>

<span class="c1">// Delete the current page's cookies</span>
<span class="kr">await</span> <span class="nx">page</span><span class="p">.</span><span class="nx">deleteCookie</span><span class="p">(</span> <span class="p">...(</span><span class="kr">await</span> <span class="nx">page</span><span class="p">.</span><span class="nx">cookies</span><span class="p">())</span> <span class="p">);</span>

<span class="c1">// Load them back in</span>
<span class="kr">await</span> <span class="nx">page</span><span class="p">.</span><span class="nx">setCookie</span><span class="p">(</span> <span class="p">...</span><span class="nx">cookies</span> <span class="p">);</span>

</code></pre></div>
<p>Hopefully some of these are helpful, hopefully the Puppeteer team will update their docs.</p>

  </div>
  
</div>

<div class="pagination">
  
    <span class="pagination-item older">Older</span>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>
    </div>

  </body>
</html>
